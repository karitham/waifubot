// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package characters

import (
	"context"
)

const count = `-- name: Count :one
SELECT
  COUNT(id)
FROM
  characters
WHERE
  user_id = $1
`

func (q *Queries) Count(ctx context.Context, userID uint64) (int64, error) {
	row := q.db.QueryRow(ctx, count, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const delete = `-- name: Delete :one
DELETE FROM characters
WHERE
  user_id = $1
  AND id = $2
RETURNING
  user_id, id, image, name, date, type
`

type DeleteParams struct {
	UserID uint64
	ID     int64
}

func (q *Queries) Delete(ctx context.Context, arg DeleteParams) (Character, error) {
	row := q.db.QueryRow(ctx, delete, arg.UserID, arg.ID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const get = `-- name: Get :one
SELECT
  user_id, id, image, name, date, type
FROM
  characters
WHERE
  id = $1
  AND characters.user_id = $2
`

type GetParams struct {
	ID     int64
	UserID uint64
}

func (q *Queries) Get(ctx context.Context, arg GetParams) (Character, error) {
	row := q.db.QueryRow(ctx, get, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const getByID = `-- name: GetByID :one
SELECT
    user_id, id, image, name, date, type
FROM
    characters
WHERE
    id = $1
LIMIT
    1
`

func (q *Queries) GetByID(ctx context.Context, id int64) (Character, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const give = `-- name: Give :one
UPDATE characters
SET
  "type" = 'TRADE',
  "user_id" = $1
WHERE
  characters.id = $2
  AND characters.user_id = $3
RETURNING
  user_id, id, image, name, date, type
`

type GiveParams struct {
	UserID   uint64
	ID       int64
	UserID_2 uint64
}

func (q *Queries) Give(ctx context.Context, arg GiveParams) (Character, error) {
	row := q.db.QueryRow(ctx, give, arg.UserID, arg.ID, arg.UserID_2)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const insert = `-- name: Insert :exec
INSERT INTO
  characters ("id", "user_id", "image", "name", "type")
VALUES
  ($1, $2, $3, $4, $5)
`

type InsertParams struct {
	ID     int64
	UserID uint64
	Image  string
	Name   string
	Type   string
}

func (q *Queries) Insert(ctx context.Context, arg InsertParams) error {
	_, err := q.db.Exec(ctx, insert,
		arg.ID,
		arg.UserID,
		arg.Image,
		arg.Name,
		arg.Type,
	)
	return err
}

const list = `-- name: List :many
SELECT
  user_id, id, image, name, date, type
FROM
  characters
WHERE
  characters.user_id = $1
ORDER BY
  characters.date DESC
`

func (q *Queries) List(ctx context.Context, userID uint64) ([]Character, error) {
	rows, err := q.db.Query(ctx, list, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIDs = `-- name: ListIDs :many
SELECT
  id
FROM
  characters
WHERE
  user_id = $1
`

func (q *Queries) ListIDs(ctx context.Context, userID uint64) ([]int64, error) {
	rows, err := q.db.Query(ctx, listIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCharacters = `-- name: SearchCharacters :many
SELECT
  user_id, id, image, name, date, type
FROM
  characters
WHERE
  user_id = $1
  AND (
    id::VARCHAR LIKE $2::VARCHAR || '%'
    OR name ILIKE '%' || $2 || '%'
  )
ORDER BY
  date DESC
LIMIT
  $4
OFFSET
  $3
`

type SearchCharactersParams struct {
	UserID uint64
	Term   string
	Off    int32
	Lim    int32
}

func (q *Queries) SearchCharacters(ctx context.Context, arg SearchCharactersParams) ([]Character, error) {
	rows, err := q.db.Query(ctx, searchCharacters,
		arg.UserID,
		arg.Term,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGlobalCharacters = `-- name: SearchGlobalCharacters :many
SELECT DISTINCT
  ON (id) id,
  name,
  image,
  type
FROM
  characters
WHERE
  id::VARCHAR LIKE $1::VARCHAR || '%'
  OR name ILIKE '%' || $1 || '%'
ORDER BY
  id,
  date DESC
LIMIT
  $2
`

type SearchGlobalCharactersParams struct {
	Term string
	Lim  int32
}

type SearchGlobalCharactersRow struct {
	ID    int64
	Name  string
	Image string
	Type  string
}

func (q *Queries) SearchGlobalCharacters(ctx context.Context, arg SearchGlobalCharactersParams) ([]SearchGlobalCharactersRow, error) {
	rows, err := q.db.Query(ctx, searchGlobalCharacters, arg.Term, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchGlobalCharactersRow
	for rows.Next() {
		var i SearchGlobalCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImageName = `-- name: UpdateImageName :one
UPDATE characters
SET
  "image" = $1,
  "name" = $2
WHERE
  id = $3
RETURNING
  user_id, id, image, name, date, type
`

type UpdateImageNameParams struct {
	Image string
	Name  string
	ID    int64
}

func (q *Queries) UpdateImageName(ctx context.Context, arg UpdateImageNameParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateImageName, arg.Image, arg.Name, arg.ID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const usersOwningCharFiltered = `-- name: UsersOwningCharFiltered :many
SELECT DISTINCT
    user_id
FROM
    characters
WHERE
    id = $1
    AND user_id = ANY ($2::bigint[])
`

type UsersOwningCharFilteredParams struct {
	ID      int64
	UserIds []int64
}

func (q *Queries) UsersOwningCharFiltered(ctx context.Context, arg UsersOwningCharFilteredParams) ([]uint64, error) {
	rows, err := q.db.Query(ctx, usersOwningCharFiltered, arg.ID, arg.UserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uint64
	for rows.Next() {
		var user_id uint64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
