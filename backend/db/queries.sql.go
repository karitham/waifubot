// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const setChar = `-- name: SetChar :one
UPDATE characters
SET
    "image" = $1,
    "name" = $2
WHERE
    id = $3
RETURNING
    user_id, id, image, name, date, type
`

type SetCharParams struct {
	Image string
	Name  string
	ID    int64
}

func (q *Queries) SetChar(ctx context.Context, arg SetCharParams) (Character, error) {
	row := q.db.QueryRow(ctx, setChar, arg.Image, arg.Name, arg.ID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const addDropToken = `-- name: addDropToken :exec
UPDATE users
SET
    tokens = tokens + 1
WHERE
    user_id = $1
`

func (q *Queries) addDropToken(ctx context.Context, userID uint64) error {
	_, err := q.db.Exec(ctx, addDropToken, userID)
	return err
}

const consumeDropTokens = `-- name: consumeDropTokens :one
UPDATE users
SET
    tokens = tokens - $1
WHERE
    user_id = $2
RETURNING
    id, user_id, quote, date, favorite, tokens, anilist_url
`

type consumeDropTokensParams struct {
	Tokens int32
	UserID uint64
}

func (q *Queries) consumeDropTokens(ctx context.Context, arg consumeDropTokensParams) (User, error) {
	row := q.db.QueryRow(ctx, consumeDropTokens, arg.Tokens, arg.UserID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
		&i.Tokens,
		&i.AnilistUrl,
	)
	return i, err
}

const createUser = `-- name: createUser :exec
INSERT INTO
    users (user_id)
VALUES
    ($1)
`

func (q *Queries) createUser(ctx context.Context, userID uint64) error {
	_, err := q.db.Exec(ctx, createUser, userID)
	return err
}

const deleteChar = `-- name: deleteChar :one
DELETE FROM characters
WHERE
    user_id = $1
    AND id = $2
RETURNING
    user_id, id, image, name, date, type
`

type deleteCharParams struct {
	UserID uint64
	ID     int64
}

func (q *Queries) deleteChar(ctx context.Context, arg deleteCharParams) (Character, error) {
	row := q.db.QueryRow(ctx, deleteChar, arg.UserID, arg.ID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const getChar = `-- name: getChar :one
SELECT
    user_id, id, image, name, date, type
FROM
    characters
WHERE
    id = $1
    AND characters.user_id = $2
`

type getCharParams struct {
	ID     int64
	UserID uint64
}

func (q *Queries) getChar(ctx context.Context, arg getCharParams) (Character, error) {
	row := q.db.QueryRow(ctx, getChar, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const getChars = `-- name: getChars :many
SELECT
    user_id, id, image, name, date, type
FROM
    characters
WHERE
    characters.user_id = $1
ORDER BY
    characters.date DESC
`

func (q *Queries) getChars(ctx context.Context, userID uint64) ([]Character, error) {
	rows, err := q.db.Query(ctx, getChars, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharsID = `-- name: getCharsID :many
SELECT
    id
FROM
    characters
WHERE
    user_id = $1
`

func (q *Queries) getCharsID(ctx context.Context, userID uint64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getCharsID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCharsWhoseIDStartWith = `-- name: getCharsWhoseIDStartWith :many
SELECT
    user_id, id, image, name, date, type
FROM
    characters
WHERE
    characters.user_id = $1
    AND characters.id::VARCHAR LIKE $2::string
ORDER BY
    characters.date DESC
LIMIT
    $4
OFFSET
    $3
`

type getCharsWhoseIDStartWithParams struct {
	UserID  uint64
	LikeStr string
	Off     int32
	Lim     int32
}

func (q *Queries) getCharsWhoseIDStartWith(ctx context.Context, arg getCharsWhoseIDStartWithParams) ([]Character, error) {
	rows, err := q.db.Query(ctx, getCharsWhoseIDStartWith,
		arg.UserID,
		arg.LikeStr,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getList = `-- name: getList :many
SELECT
    user_id, id, image, name, date, type
FROM
    characters
WHERE
    user_id = $1
`

func (q *Queries) getList(ctx context.Context, userID uint64) ([]Character, error) {
	rows, err := q.db.Query(ctx, getList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Image,
			&i.Name,
			&i.Date,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfile = `-- name: getProfile :one
SELECT
    users.user_id,
    users.quote,
    users.date AS roll_date,
    users.favorite,
    users.tokens,
    users.anilist_url
FROM
    users
WHERE
    users.user_id = $1
`

type getProfileRow struct {
	UserID     uint64
	Quote      string
	RollDate   pgtype.Timestamp
	Favorite   pgtype.Int8
	Tokens     int32
	AnilistUrl string
}

func (q *Queries) getProfile(ctx context.Context, userID uint64) (getProfileRow, error) {
	row := q.db.QueryRow(ctx, getProfile, userID)
	var i getProfileRow
	err := row.Scan(
		&i.UserID,
		&i.Quote,
		&i.RollDate,
		&i.Favorite,
		&i.Tokens,
		&i.AnilistUrl,
	)
	return i, err
}

const getProfileOverview = `-- name: getProfileOverview :one
SELECT
    characters.image AS favorite_image,
    characters.name AS favorite_name,
    characters.id AS favorite_id,
    users.date AS user_date,
    users.quote AS user_quote,
    users.user_id AS user_id,
    users.tokens AS user_tokens,
    users.anilist_url AS user_anilist_url,
    (
        SELECT
            COUNT(id)
        FROM
            characters
        WHERE
            characters.user_id = $1
    ) AS count
FROM
    users
    LEFT JOIN characters ON characters.id = users.favorite
WHERE
    users.user_id = $1
`

type getProfileOverviewRow struct {
	FavoriteImage  pgtype.Text
	FavoriteName   pgtype.Text
	FavoriteID     pgtype.Int8
	UserDate       pgtype.Timestamp
	UserQuote      string
	UserID         uint64
	UserTokens     int32
	UserAnilistUrl string
	Count          int64
}

func (q *Queries) getProfileOverview(ctx context.Context, userID uint64) (getProfileOverviewRow, error) {
	row := q.db.QueryRow(ctx, getProfileOverview, userID)
	var i getProfileOverviewRow
	err := row.Scan(
		&i.FavoriteImage,
		&i.FavoriteName,
		&i.FavoriteID,
		&i.UserDate,
		&i.UserQuote,
		&i.UserID,
		&i.UserTokens,
		&i.UserAnilistUrl,
		&i.Count,
	)
	return i, err
}

const getUser = `-- name: getUser :one
SELECT
    id, user_id, quote, date, favorite, tokens, anilist_url
FROM
    users
WHERE
    user_id = $1
`

func (q *Queries) getUser(ctx context.Context, userID uint64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
		&i.Tokens,
		&i.AnilistUrl,
	)
	return i, err
}

const getUserByAnilist = `-- name: getUserByAnilist :one
SELECT
    users.user_id,
    users.quote,
    users.date AS roll_date,
    users.favorite,
    users.tokens,
    users.anilist_url
FROM
    users
WHERE
    users.anilist_url = $1
`

type getUserByAnilistRow struct {
	UserID     uint64
	Quote      string
	RollDate   pgtype.Timestamp
	Favorite   pgtype.Int8
	Tokens     int32
	AnilistUrl string
}

func (q *Queries) getUserByAnilist(ctx context.Context, anilistUrl string) (getUserByAnilistRow, error) {
	row := q.db.QueryRow(ctx, getUserByAnilist, anilistUrl)
	var i getUserByAnilistRow
	err := row.Scan(
		&i.UserID,
		&i.Quote,
		&i.RollDate,
		&i.Favorite,
		&i.Tokens,
		&i.AnilistUrl,
	)
	return i, err
}

const giveChar = `-- name: giveChar :one
UPDATE characters
SET
    "type" = 'TRADE',
    "user_id" = $1
WHERE
    characters.id = $2
    AND characters.user_id = $3
RETURNING
    user_id, id, image, name, date, type
`

type giveCharParams struct {
	Given uint64
	ID    int64
	Giver uint64
}

func (q *Queries) giveChar(ctx context.Context, arg giveCharParams) (Character, error) {
	row := q.db.QueryRow(ctx, giveChar, arg.Given, arg.ID, arg.Giver)
	var i Character
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Type,
	)
	return i, err
}

const insertChar = `-- name: insertChar :exec
INSERT INTO
    characters ("id", "user_id", "image", "name", "type")
VALUES
    ($1, $2, $3, $4, $5)
`

type insertCharParams struct {
	ID     int64
	UserID uint64
	Image  string
	Name   string
	Type   string
}

func (q *Queries) insertChar(ctx context.Context, arg insertCharParams) error {
	_, err := q.db.Exec(ctx, insertChar,
		arg.ID,
		arg.UserID,
		arg.Image,
		arg.Name,
		arg.Type,
	)
	return err
}
