// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package guildstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const completeIndexingJob = `-- name: CompleteIndexingJob :exec
UPDATE guild_indexing_jobs
SET
  status = 'completed',
  updated_at = NOW()
WHERE
  guild_id = $1
`

func (q *Queries) CompleteIndexingJob(ctx context.Context, guildID uint64) error {
	_, err := q.db.Exec(ctx, completeIndexingJob, guildID)
	return err
}

const deleteGuildMembers = `-- name: DeleteGuildMembers :exec
DELETE FROM guild_members
WHERE
  guild_id = $1
`

func (q *Queries) DeleteGuildMembers(ctx context.Context, guildID uint64) error {
	_, err := q.db.Exec(ctx, deleteGuildMembers, guildID)
	return err
}

const deleteGuildMembersNotIn = `-- name: DeleteGuildMembersNotIn :exec
DELETE FROM guild_members
WHERE guild_id = $1 AND user_id NOT IN (SELECT unnest($2::bigint[]))
`

type DeleteGuildMembersNotInParams struct {
	GuildID uint64
	Column2 []int64
}

func (q *Queries) DeleteGuildMembersNotIn(ctx context.Context, arg DeleteGuildMembersNotInParams) error {
	_, err := q.db.Exec(ctx, deleteGuildMembersNotIn, arg.GuildID, arg.Column2)
	return err
}

const getGuildMembers = `-- name: GetGuildMembers :many
SELECT
  user_id
FROM
  guild_members
WHERE
  guild_id = $1
`

func (q *Queries) GetGuildMembers(ctx context.Context, guildID uint64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getGuildMembers, guildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndexingStatus = `-- name: GetIndexingStatus :one
SELECT
  status,
  updated_at
FROM
  guild_indexing_jobs
WHERE
  guild_id = $1
`

type GetIndexingStatusRow struct {
	Status    IndexingStatus
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) GetIndexingStatus(ctx context.Context, guildID uint64) (GetIndexingStatusRow, error) {
	row := q.db.QueryRow(ctx, getIndexingStatus, guildID)
	var i GetIndexingStatusRow
	err := row.Scan(&i.Status, &i.UpdatedAt)
	return i, err
}

const isGuildIndexed = `-- name: IsGuildIndexed :one
SELECT
  status,
  updated_at
FROM
  guild_indexing_jobs
WHERE
  guild_id = $1
`

type IsGuildIndexedRow struct {
	Status    IndexingStatus
	UpdatedAt pgtype.Timestamp
}

func (q *Queries) IsGuildIndexed(ctx context.Context, guildID uint64) (IsGuildIndexedRow, error) {
	row := q.db.QueryRow(ctx, isGuildIndexed, guildID)
	var i IsGuildIndexedRow
	err := row.Scan(&i.Status, &i.UpdatedAt)
	return i, err
}

const startIndexingJob = `-- name: StartIndexingJob :exec
INSERT INTO
  guild_indexing_jobs (guild_id, status, updated_at)
VALUES
  ($1, 'in_progress', NOW())
ON CONFLICT (guild_id) DO UPDATE
SET
  status = 'in_progress',
  updated_at = NOW()
`

func (q *Queries) StartIndexingJob(ctx context.Context, guildID uint64) error {
	_, err := q.db.Exec(ctx, startIndexingJob, guildID)
	return err
}

const upsertGuildMembers = `-- name: UpsertGuildMembers :exec
INSERT INTO guild_members (guild_id, user_id, indexed_at)
SELECT $1, unnest($2::bigint[]), $3
ON CONFLICT (guild_id, user_id) DO UPDATE SET indexed_at = EXCLUDED.indexed_at
`

type UpsertGuildMembersParams struct {
	GuildID   uint64
	Column2   []int64
	IndexedAt pgtype.Timestamp
}

func (q *Queries) UpsertGuildMembers(ctx context.Context, arg UpsertGuildMembersParams) error {
	_, err := q.db.Exec(ctx, upsertGuildMembers, arg.GuildID, arg.Column2, arg.IndexedAt)
	return err
}

const usersOwningCharInGuild = `-- name: UsersOwningCharInGuild :many
SELECT DISTINCT
  c.user_id
FROM
  characters c
  JOIN guild_members gm ON c.user_id = gm.user_id
WHERE
  c.id = $1
  AND gm.guild_id = $2
`

type UsersOwningCharInGuildParams struct {
	ID      int64
	GuildID uint64
}

func (q *Queries) UsersOwningCharInGuild(ctx context.Context, arg UsersOwningCharInGuildParams) ([]uint64, error) {
	rows, err := q.db.Query(ctx, usersOwningCharInGuild, arg.ID, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uint64
	for rows.Next() {
		var user_id uint64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
