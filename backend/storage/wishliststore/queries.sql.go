// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package wishliststore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCharacterToWishlist = `-- name: AddCharacterToWishlist :exec
INSERT INTO character_wishlist (user_id, character_id)
VALUES ($1, $2)
ON CONFLICT (user_id, character_id) DO NOTHING
`

type AddCharacterToWishlistParams struct {
	UserID      uint64
	CharacterID int64
}

func (q *Queries) AddCharacterToWishlist(ctx context.Context, arg AddCharacterToWishlistParams) error {
	_, err := q.db.Exec(ctx, addCharacterToWishlist, arg.UserID, arg.CharacterID)
	return err
}

const addMultipleCharactersToWishlist = `-- name: AddMultipleCharactersToWishlist :exec
INSERT INTO character_wishlist (user_id, character_id)
SELECT $1, unnest($2::bigint[])
ON CONFLICT (user_id, character_id) DO NOTHING
`

type AddMultipleCharactersToWishlistParams struct {
	UserID  uint64
	Column2 []int64
}

func (q *Queries) AddMultipleCharactersToWishlist(ctx context.Context, arg AddMultipleCharactersToWishlistParams) error {
	_, err := q.db.Exec(ctx, addMultipleCharactersToWishlist, arg.UserID, arg.Column2)
	return err
}

const compareWithUser = `-- name: CompareWithUser :many
SELECT
    'has' as type,
    c.id,
    c.name,
    c.image,
    cw.created_at as date
FROM character_wishlist cw
JOIN characters c ON cw.character_id = c.id
JOIN collection col ON col.character_id = c.id AND col.user_id = $2
WHERE cw.user_id = $1
UNION ALL
SELECT
    'wants' as type,
    c.id,
    c.name,
    c.image,
    cw.created_at as date
FROM character_wishlist cw
JOIN characters c ON cw.character_id = c.id
WHERE cw.user_id = $2
AND cw.character_id IN (
    SELECT col.character_id
    FROM collection col
    WHERE col.user_id = $1
)
`

type CompareWithUserParams struct {
	UserID   uint64
	UserID_2 uint64
}

type CompareWithUserRow struct {
	Type  string
	ID    int64
	Name  string
	Image string
	Date  pgtype.Timestamp
}

func (q *Queries) CompareWithUser(ctx context.Context, arg CompareWithUserParams) ([]CompareWithUserRow, error) {
	rows, err := q.db.Query(ctx, compareWithUser, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CompareWithUserRow
	for rows.Next() {
		var i CompareWithUserRow
		if err := rows.Scan(
			&i.Type,
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCharacterWishlist = `-- name: GetUserCharacterWishlist :many
SELECT
    c.id,
    c.name,
    c.image,
    cw.created_at as date
FROM character_wishlist cw
JOIN characters c ON cw.character_id = c.id
WHERE cw.user_id = $1
ORDER BY cw.created_at DESC
`

type GetUserCharacterWishlistRow struct {
	ID    int64
	Name  string
	Image string
	Date  pgtype.Timestamp
}

func (q *Queries) GetUserCharacterWishlist(ctx context.Context, userID uint64) ([]GetUserCharacterWishlistRow, error) {
	rows, err := q.db.Query(ctx, getUserCharacterWishlist, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCharacterWishlistRow
	for rows.Next() {
		var i GetUserCharacterWishlistRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWantedCharacters = `-- name: GetWantedCharacters :many
SELECT
    cw.user_id as user_id,
    c.id as character_id,
    c.name as character_name,
    c.image as character_image
FROM character_wishlist cw
JOIN characters c ON cw.character_id = c.id
JOIN collection col ON col.character_id = c.id
WHERE col.user_id = $1
AND cw.user_id != $1
`

type GetWantedCharactersRow struct {
	UserID         uint64
	CharacterID    int64
	CharacterName  string
	CharacterImage string
}

func (q *Queries) GetWantedCharacters(ctx context.Context, userID uint64) ([]GetWantedCharactersRow, error) {
	rows, err := q.db.Query(ctx, getWantedCharacters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWantedCharactersRow
	for rows.Next() {
		var i GetWantedCharactersRow
		if err := rows.Scan(
			&i.UserID,
			&i.CharacterID,
			&i.CharacterName,
			&i.CharacterImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWishlistHolders = `-- name: GetWishlistHolders :many
SELECT
    col.user_id as user_id,
    c.id as character_id,
    c.name as character_name,
    c.image as character_image
FROM collection col
JOIN characters c ON col.character_id = c.id
LEFT JOIN guild_members gm ON gm.user_id = col.user_id AND gm.guild_id = $3
WHERE col.character_id = ANY($1::bigint[])
AND col.user_id != $2
AND ($3 = 0 OR gm.guild_id IS NOT NULL)
`

type GetWishlistHoldersParams struct {
	Column1 []int64
	UserID  uint64
	GuildID uint64
}

type GetWishlistHoldersRow struct {
	UserID         uint64
	CharacterID    int64
	CharacterName  string
	CharacterImage string
}

func (q *Queries) GetWishlistHolders(ctx context.Context, arg GetWishlistHoldersParams) ([]GetWishlistHoldersRow, error) {
	rows, err := q.db.Query(ctx, getWishlistHolders, arg.Column1, arg.UserID, arg.GuildID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWishlistHoldersRow
	for rows.Next() {
		var i GetWishlistHoldersRow
		if err := rows.Scan(
			&i.UserID,
			&i.CharacterID,
			&i.CharacterName,
			&i.CharacterImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeCharacterFromWishlist = `-- name: RemoveCharacterFromWishlist :exec
DELETE FROM character_wishlist
WHERE user_id = $1 AND character_id = $2
`

type RemoveCharacterFromWishlistParams struct {
	UserID      uint64
	CharacterID int64
}

func (q *Queries) RemoveCharacterFromWishlist(ctx context.Context, arg RemoveCharacterFromWishlistParams) error {
	_, err := q.db.Exec(ctx, removeCharacterFromWishlist, arg.UserID, arg.CharacterID)
	return err
}

const removeMultipleCharactersFromWishlist = `-- name: RemoveMultipleCharactersFromWishlist :exec
DELETE FROM character_wishlist
WHERE user_id = $1 AND character_id = ANY($2::bigint[])
`

type RemoveMultipleCharactersFromWishlistParams struct {
	UserID  uint64
	Column2 []int64
}

func (q *Queries) RemoveMultipleCharactersFromWishlist(ctx context.Context, arg RemoveMultipleCharactersFromWishlistParams) error {
	_, err := q.db.Exec(ctx, removeMultipleCharactersFromWishlist, arg.UserID, arg.Column2)
	return err
}
