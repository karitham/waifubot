// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package collectionstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const count = `-- name: Count :one
SELECT 
    COUNT(col.character_id)
FROM collection col
WHERE col.user_id = $1
`

func (q *Queries) Count(ctx context.Context, userID uint64) (int64, error) {
	row := q.db.QueryRow(ctx, count, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const delete = `-- name: Delete :one
DELETE FROM collection col
WHERE col.user_id = $1
AND col.character_id = $2
RETURNING user_id, character_id, source, acquired_at
`

type DeleteParams struct {
	UserID      uint64
	CharacterID int64
}

func (q *Queries) Delete(ctx context.Context, arg DeleteParams) (Collection, error) {
	row := q.db.QueryRow(ctx, delete, arg.UserID, arg.CharacterID)
	var i Collection
	err := row.Scan(
		&i.UserID,
		&i.CharacterID,
		&i.Source,
		&i.AcquiredAt,
	)
	return i, err
}

const get = `-- name: Get :one
SELECT 
    c.id,
    c.name,
    c.image,
    col.source,
    col.acquired_at as date
FROM collection col
JOIN characters c ON col.character_id = c.id
WHERE c.id = $1
AND col.user_id = $2
`

type GetParams struct {
	ID     int64
	UserID uint64
}

type GetRow struct {
	ID     int64
	Name   string
	Image  string
	Source string
	Date   pgtype.Timestamp
}

func (q *Queries) Get(ctx context.Context, arg GetParams) (GetRow, error) {
	row := q.db.QueryRow(ctx, get, arg.ID, arg.UserID)
	var i GetRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.Source,
		&i.Date,
	)
	return i, err
}

const getByID = `-- name: GetByID :one
SELECT 
    id,
    name,
    image
FROM characters
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetByID(ctx context.Context, id int64) (Character, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i Character
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const give = `-- name: Give :one
UPDATE collection col
SET 
    user_id = $1,
    source = 'TRADE'
WHERE col.character_id = $2
AND col.user_id = $3
RETURNING user_id, character_id, source, acquired_at
`

type GiveParams struct {
	UserID      uint64
	CharacterID int64
	UserID_2    uint64
}

func (q *Queries) Give(ctx context.Context, arg GiveParams) (Collection, error) {
	row := q.db.QueryRow(ctx, give, arg.UserID, arg.CharacterID, arg.UserID_2)
	var i Collection
	err := row.Scan(
		&i.UserID,
		&i.CharacterID,
		&i.Source,
		&i.AcquiredAt,
	)
	return i, err
}

const insert = `-- name: Insert :one
INSERT INTO collection (user_id, character_id, source, acquired_at)
VALUES ($1, $2, $3, $4)
RETURNING user_id, character_id, source, acquired_at
`

type InsertParams struct {
	UserID      uint64
	CharacterID int64
	Source      string
	AcquiredAt  pgtype.Timestamp
}

func (q *Queries) Insert(ctx context.Context, arg InsertParams) (Collection, error) {
	row := q.db.QueryRow(ctx, insert,
		arg.UserID,
		arg.CharacterID,
		arg.Source,
		arg.AcquiredAt,
	)
	var i Collection
	err := row.Scan(
		&i.UserID,
		&i.CharacterID,
		&i.Source,
		&i.AcquiredAt,
	)
	return i, err
}

const list = `-- name: List :many
SELECT 
    c.id,
    c.name,
    c.image,
    col.source,
    col.acquired_at as date
FROM collection col
JOIN characters c ON col.character_id = c.id
WHERE col.user_id = $1
ORDER BY col.acquired_at DESC
`

type ListRow struct {
	ID     int64
	Name   string
	Image  string
	Source string
	Date   pgtype.Timestamp
}

func (q *Queries) List(ctx context.Context, userID uint64) ([]ListRow, error) {
	rows, err := q.db.Query(ctx, list, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRow
	for rows.Next() {
		var i ListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Source,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIDs = `-- name: ListIDs :many
SELECT 
    col.character_id as id
FROM collection col
WHERE col.user_id = $1
`

func (q *Queries) ListIDs(ctx context.Context, userID uint64) ([]int64, error) {
	rows, err := q.db.Query(ctx, listIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCharacters = `-- name: SearchCharacters :many
SELECT 
    c.id,
    c.name,
    c.image,
    col.source,
    col.acquired_at as date
FROM collection col
JOIN characters c ON col.character_id = c.id
WHERE col.user_id = $1
AND (
    c.id::VARCHAR LIKE $2::VARCHAR || '%'
    OR c.name ILIKE '%' || $2 || '%'
)
ORDER BY col.acquired_at DESC
LIMIT $4
OFFSET $3
`

type SearchCharactersParams struct {
	UserID uint64
	Term   string
	Off    int32
	Lim    int32
}

type SearchCharactersRow struct {
	ID     int64
	Name   string
	Image  string
	Source string
	Date   pgtype.Timestamp
}

func (q *Queries) SearchCharacters(ctx context.Context, arg SearchCharactersParams) ([]SearchCharactersRow, error) {
	rows, err := q.db.Query(ctx, searchCharacters,
		arg.UserID,
		arg.Term,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCharactersRow
	for rows.Next() {
		var i SearchCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Source,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGlobalCharacters = `-- name: SearchGlobalCharacters :many
SELECT DISTINCT 
    c.id,
    c.name,
    c.image
FROM characters c
WHERE 
    c.id::VARCHAR LIKE $1::VARCHAR || '%'
    OR c.name ILIKE '%' || $1 || '%'
ORDER BY c.id
LIMIT $2
`

type SearchGlobalCharactersParams struct {
	Term string
	Lim  int32
}

func (q *Queries) SearchGlobalCharacters(ctx context.Context, arg SearchGlobalCharactersParams) ([]Character, error) {
	rows, err := q.db.Query(ctx, searchGlobalCharacters, arg.Term, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(&i.ID, &i.Name, &i.Image); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateImageName = `-- name: UpdateImageName :one
UPDATE characters c
SET 
    image = $1,
    name = $2
WHERE c.id = $3
RETURNING id, name, image
`

type UpdateImageNameParams struct {
	Image string
	Name  string
	ID    int64
}

func (q *Queries) UpdateImageName(ctx context.Context, arg UpdateImageNameParams) (Character, error) {
	row := q.db.QueryRow(ctx, updateImageName, arg.Image, arg.Name, arg.ID)
	var i Character
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const upsertCharacter = `-- name: UpsertCharacter :one
INSERT INTO characters (id, name, image)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    image = EXCLUDED.image
RETURNING id, name, image
`

type UpsertCharacterParams struct {
	ID    int64
	Name  string
	Image string
}

func (q *Queries) UpsertCharacter(ctx context.Context, arg UpsertCharacterParams) (Character, error) {
	row := q.db.QueryRow(ctx, upsertCharacter, arg.ID, arg.Name, arg.Image)
	var i Character
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const usersOwningCharFiltered = `-- name: UsersOwningCharFiltered :many
SELECT DISTINCT 
    col.user_id
FROM collection col
WHERE col.character_id = $1
AND col.user_id = ANY ($2::bigint[])
`

type UsersOwningCharFilteredParams struct {
	CharacterID int64
	UserIds     []int64
}

func (q *Queries) UsersOwningCharFiltered(ctx context.Context, arg UsersOwningCharFilteredParams) ([]uint64, error) {
	rows, err := q.db.Query(ctx, usersOwningCharFiltered, arg.CharacterID, arg.UserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uint64
	for rows.Next() {
		var user_id uint64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
